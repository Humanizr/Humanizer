{"name":"Humanizer","tagline":"Humanizer meets all your .NET needs for manipulating and displaying strings, enums, dates, times, timespans, numbers and quantities","body":"<p><img src=\"https://raw.github.com/MehdiK/Humanizer/master/logo.png\" alt=\"Logo\" style=\"max-width:100%;\" /></p>\r\n\r\nHumanizer meets all your .NET needs for manipulating and displaying strings, enums, dates, times, timespans, numbers and quantities.\r\n\r\n###Table of contents\r\n - [Install](#install)\r\n - [Features](#features)\r\n   - [Humanize String](#humanize-string)\r\n   - [Dehumanize String](#dehumanize-string)\r\n   - [Transform String](#transform-string)\r\n   - [Truncate String](#truncate-string)\r\n   - [Format String](#format-string)\r\n   - [Humanize Enums](#humanize-enums)\r\n   - [Dehumanize Enums](#dehumanize-enums)\r\n   - [Humanize DateTime](#humanize-datetime)\r\n   - [Humanize TimeSpan](#humanize-timespan)\r\n   - [Humanize Collections](#humanize-collections)\r\n   - [Inflector methods](#inflector-methods)\r\n     - [Pluralize](#pluralize)\r\n     - [Singularize](#singularize)\r\n     - [ToQuantity](#toquantity)\r\n     - [Ordinalize](#ordinalize)\r\n     - [Underscore](#underscore)\r\n     - [Dasherize & Hyphenate](#dasherize--hyphenate)\r\n   - [Fluent date](#fluent-date)\r\n   - [Number to words](#number-to-words)\r\n   - [Number to ordinal words](#number-to-ordinal-words)\r\n   - [Roman numerals](#roman-numerals)\r\n   - [ByteSize](#bytesize)\r\n - [Mix this into your framework to simplify your life](#mix-this-into-your-framework-to-simplify-your-life)\r\n - [How to contribute?](#how-to-contribute)\r\n - [Continuous Integration from TeamCity](#continuous-integration-from-teamcity)\r\n - [Author](#author)\r\n - [Main contributors](#main-contributors)\r\n - [License](#license)\r\n - [Icon](#icon)\r\n\r\n##<a id=\"install\">Install</a>\r\nYou can install Humanizer as [a nuget package](https://nuget.org/packages/Humanizer): `Install-Package Humanizer`\r\n\r\nHumanizer is a Portable Class Library with support for .Net 4+, SilverLight 5, Windows Phone 8 and Win Store applications.\r\nAlso Humanizer [symbols nuget package](http://www.symbolsource.org/Public/Metadata/NuGet/Project/Humanizer) is published so you can [step through Humanizer code](http://www.symbolsource.org/Public/Home/VisualStudio) while debugging your code.\r\n\r\n##<a id=\"features\">Features</a>\r\n\r\n###<a id=\"humanize-string\">Humanize String</a>\r\n`Humanize` string extensions allow you turn an otherwise computerized string into a more readable human-friendly one.\r\nThe foundation of this was set in the [BDDfy framework](https://github.com/TestStack/TestStack.BDDfy) where class names, method names and properties are turned into human readable sentences.\r\n\r\n```C#\r\n\"PascalCaseInputStringIsTurnedIntoSentence\".Humanize() => \"Pascal case input string is turned into sentence\"\r\n\r\n\"Underscored_input_string_is_turned_into_sentence\".Humanize() => \"Underscored input string is turned into sentence\"\r\n\r\n\"Underscored_input_String_is_turned_INTO_sentence\".Humanize() => \"Underscored input String is turned INTO sentence\"\r\n\r\n// acronyms are left intact\r\n\"HTML\".Humanize() => \"HTML\"\r\n```\r\n\r\nYou may also specify the desired letter casing:\r\n\r\n```C#\r\n\"CanReturnTitleCase\".Humanize(LetterCasing.Title) => \"Can Return Title Case\"\r\n\r\n\"Can_return_title_Case\".Humanize(LetterCasing.Title) => \"Can Return Title Case\"\r\n\r\n\"CanReturnLowerCase\".Humanize(LetterCasing.LowerCase) => \"can return lower case\"\r\n\r\n\"CanHumanizeIntoUpperCase\".Humanize(LetterCasing.AllCaps) => \"CAN HUMANIZE INTO UPPER CASE\"\r\n```\r\n\r\n > The `LetterCasing` API and the methods accepting it are legacy from V0.2 era and will be deprecated in the future. Instead of that, you can use `Transform` method explained below.\r\n\r\n###<a id=\"dehumanize-string\">Dehumanize String</a>\r\nMuch like you can humanize a computer friendly into human friendly string you can dehumanize a human friendly string into a computer friendly one:\r\n\r\n```C#\r\n\"Pascal case input string is turned into sentence\".Dehumanize() => \"PascalCaseInputStringIsTurnedIntoSentence\"\r\n```\r\n\r\n###<a id=\"transform-string\">Transform String</a>\r\nThere is a `Transform` method that supersedes `LetterCasing`, `ApplyCase` and `Humanize` overloads that accept `LetterCasing`.\r\nTransform method signature is as follows:\r\n\r\n```C#\r\nstring Transform(this string input, params IStringTransformer[] transformers)\r\n```\r\n\r\nAnd there are some out of the box implementations of `IStringTransformer` for letter casing:\r\n\r\n```C#\r\n\"Sentence casing\".Transform(To.LowerCase) => \"sentence casing\"\r\n\"Sentence casing\".Transform(To.SentenceCase) => \"Sentence casing\"\r\n\"Sentence casing\".Transform(To.TitleCase) => \"Sentence Casing\"\r\n\"Sentence casing\".Transform(To.UpperCase) => \"SENTENCE CASING\"\r\n```\r\n\r\n`LowerCase` is a public static property on `To` class that returns an instance of private `ToLowerCase` class that implements `IStringTransformer` and knows how to turn a string into lower case.\r\n\r\nThe benefit of using `Transform` and `IStringTransformer` over `ApplyCase` and `LetterCasing` is that `LetterCasing` is an enum and you're limited to use what's in the framework\r\nwhile `IStringTransformer` is an interface you can implement in your codebase once and use it with `Transform` method allowing for easy extension.\r\n\r\n###<a id=\"truncate-string\">Truncate String</a>\r\nYou can truncate a `string` using the `Truncate` method:\r\n\r\n```c#\r\n\"Long text to truncate\".Truncate(10) => \"Long text…\"\r\n```\r\n\r\nBy default the `'…'` character is used to truncate strings. The advantage of using the `'…'` character instead of `\"...\"` is that the former only takes a single character and thus allows more text to be shown before truncation. If you want, you can also provide your own truncation string:\r\n\r\n```c#\r\n\"Long text to truncate\".Truncate(10, \"---\") => \"Long te---\"\r\n```\r\n\r\nThe default truncation strategy, `Truncator.FixedLength`, is to truncate the input string to a specific length, including the truncation string length.\r\nThere are two more truncator strategies available: one for a fixed number of (alpha-numerical) characters and one for a fixed number of words.\r\nTo use a specific truncator when truncating, the two `Truncate` methods shown in the previous examples all have an overload that allow you to specify the `ITruncator` instance to use for the truncation.\r\nHere are examples on how to use the three provided truncators:\r\n\r\n```c#\r\n\"Long text to truncate\".Truncate(10, Truncator.FixedLength) => \"Long text…\"\r\n\"Long text to truncate\".Truncate(10, \"---\", Truncator.FixedLength) => \"Long te---\"\r\n\r\n\"Long text to truncate\".Truncate(6, Truncator.FixedNumberOfCharacters) => \"Long t…\"\r\n\"Long text to truncate\".Truncate(6, \"---\", Truncator.FixedNumberOfCharacters) => \"Lon---\"\r\n\r\n\"Long text to truncate\".Truncate(2, Truncator.FixedNumberOfWords) => \"Long text…\"\r\n\"Long text to truncate\".Truncate(2, \"---\", Truncator.FixedNumberOfWords) => \"Long text---\"\r\n```\r\n\r\nNote that you can also use create your own truncator by implementing the `ITruncator` interface.\r\n\r\nThere is also an option to choose whether to truncate the string from the beginning (`TruncateFrom.Left`) or the end (`TruncateFrom.Right`).\r\nDefault is the right as shown in the examples above. The examples below show how to truncate from the beginning of the string:\r\n\r\n```c#\r\n\"Long text to truncate\".Truncate(10, Truncator.FixedLength, TruncateFrom.Left) => \"… truncate\"\r\n\"Long text to truncate\".Truncate(10, \"---\", Truncator.FixedLength, TruncateFrom.Left) => \"---runcate\"\r\n\r\n\"Long text to truncate\".Truncate(10, Truncator.FixedNumberOfCharacters, TruncateFrom.Left) => \"…o truncate\"\r\n\"Long text to truncate\".Truncate(16, \"---\", Truncator.FixedNumberOfCharacters, TruncateFrom.Left) => \"---ext to truncate\"\r\n\r\n\"Long text to truncate\".Truncate(2, Truncator.FixedNumberOfWords, TruncateFrom.Left) => \"…to truncate\"\r\n\"Long text to truncate\".Truncate(2, \"---\", Truncator.FixedNumberOfWords, TruncateFrom.Left) => \"---to truncate\"\r\n```\r\n\r\n###<a id=\"format-string\">Format String</a>\r\nYou can format a `string` using the `FormatWith()` method:\r\n\r\n```c#\r\n\"To be formatted -> {0}/{1}.\".FormatWith(1, \"A\") => \"To be formated -> 1/A.\"\r\n```\r\n\r\nThis is an extension method based on `String.Format`, so exact rules applies to it.\r\nIf `format` is null, it'll throw `ArgumentNullException`.\r\nIf passed a fewer number for arguments, it'll throw `String.FormatException` exception.\r\n\r\n###<a id=\"humanize-enums\">Humanize Enums</a>\r\nCalling `ToString` directly on enum members usually results in less than ideal output for users. The solution to this is usually to use `DescriptionAttribute` data annotation and then read that at runtime to get a more friendly output. That is a great solution; but more often than not we only need to put some space between words of an enum member - which is what `String.Humanize()` does well. For an enum like:\r\n\r\n```C#\r\npublic enum EnumUnderTest\r\n{\r\n    [Description(\"Custom description\")]\r\n    MemberWithDescriptionAttribute,\r\n    MemberWithoutDescriptionAttribute,\r\n    ALLCAPITALS\r\n}\r\n```\r\n\r\nYou will get:\r\n\r\n```C#\r\n// DescriptionAttribute is honored\r\nEnumUnderTest.MemberWithDescriptionAttribute.Humanize() => \"Custom description\"\r\n\r\n// In the absence of Description attribute string.Humanizer kicks in\r\nEnumUnderTest.MemberWithoutDescriptionAttribute.Humanize() => \"Member without description attribute\"\r\n\r\n// Of course you can still apply letter casing\r\nEnumUnderTest.MemberWithoutDescriptionAttribute.Humanize().Transform(To.TitleCase) => \"Member Without Description Attribute\"\r\n```\r\n\r\nYou are not limited to `DescriptionAttribute` for custom description. Any attribute applied on enum members with a `string Description` property counts.\r\nThis is to help with platforms with missing `DescriptionAttribute` and also for allowing subclasses of the `DescriptionAttribute`.\r\n\r\nYou can even configure the name of the property of attibute to use as description.\r\n\r\n`Configurator.EnumDescriptionPropertyLocator = p => p.Name == \"Info\"`\r\n\r\nHopefully this will help avoid littering enums with unnecessary attributes!\r\n\r\n###<a id=\"dehumanize-enums\">Dehumanize Enums</a>\r\nDehumanizes a string into the Enum it was originally Humanized from! The API looks like:\r\n\r\n```C#\r\npublic static TTargetEnum DehumanizeTo<TTargetEnum>(this string input)\r\n```\r\n\r\nAnd the usage is:\r\n\r\n```C#\r\n\"Member without description attribute\".DehumanizeTo<EnumUnderTest>() => EnumUnderTest.MemberWithoutDescriptionAttribute\r\n```\r\n\r\nAnd just like the Humanize API it honors the `Description` attribute. You don't have to provide the casing you provided during humanization: it figures it out.\r\n\r\nThere is also a non-generic counterpart for when the original Enum is not known at compile time:\r\n\r\n```C#\r\npublic static Enum DehumanizeTo(this string input, Type targetEnum, NoMatch onNoMatch = NoMatch.ThrowsException)\r\n```\r\n\r\nwhich can be used like:\r\n\r\n```C#\r\n\"Member without description attribute\".DehumanizeTo(typeof(EnumUnderTest)) => EnumUnderTest.MemberWithoutDescriptionAttribute\r\n```\r\n\r\nBy default both methods throw a `NoMatchFoundException` when they cannot match the provided input against the target enum.\r\nIn the non-generic method you can also ask the method to return null by setting the second optional parameter to `NoMatch.ReturnsNull`.\r\n\r\n###<a id=\"humanize-datetime\">Humanize DateTime</a>\r\nYou can `Humanize` an instance of `DateTime` and get back a string telling how far back or forward in time that is:\r\n\r\n```C#\r\nDateTime.UtcNow.AddHours(-30).Humanize() => \"yesterday\"\r\nDateTime.UtcNow.AddHours(-2).Humanize() => \"2 hours ago\"\r\n\r\nDateTime.UtcNow.AddHours(30).Humanize() => \"tomorrow\"\r\nDateTime.UtcNow.AddHours(2).Humanize() => \"2 hours from now\"\r\n```\r\n\r\nHumanizer supports local as well as UTC dates. You could also provide the date you want the input date to be compared against. If null, it will use the current date as comparison base.\r\nAlso, culture to use can be specified explicitly. If it is not, current thread's current UI culture is used.\r\nHere is the API signature:\r\n\r\n```C#\r\npublic static string Humanize(this DateTime input, bool utcDate = true, DateTime? dateToCompareAgainst = null, CultureInfo culture = null)\r\n```\r\n\r\nMany localizations are available for this method. Here is a few examples:\r\n\r\n```C#\r\n// In ar culture\r\nDateTime.UtcNow.AddDays(-1).Humanize() => \"أمس\"\r\nDateTime.UtcNow.AddDays(-2).Humanize() => \"منذ يومين\"\r\nDateTime.UtcNow.AddDays(-3).Humanize() => \"منذ 3 أيام\"\r\nDateTime.UtcNow.AddDays(-11).Humanize() => \"منذ 11 يوم\"\r\n\r\n// In ru-RU culture\r\nDateTime.UtcNow.AddMinutes(-1).Humanize() => \"минуту назад\"\r\nDateTime.UtcNow.AddMinutes(-2).Humanize() => \"2 минуты назад\"\r\nDateTime.UtcNow.AddMinutes(-10).Humanize() => \"10 минут назад\"\r\nDateTime.UtcNow.AddMinutes(-21).Humanize() => \"21 минуту назад\"\r\nDateTime.UtcNow.AddMinutes(-22).Humanize() => \"22 минуты назад\"\r\nDateTime.UtcNow.AddMinutes(-40).Humanize() => \"40 минут назад\"\r\n```\r\n\r\nThere are two strategies for `DateTime.Humanize`: the default one as seen above and a precision based one.\r\nTo use the precision based strategy you need to configure it:\r\n\r\n`Configurator.DateTimeHumanizeStrategy = new PrecisionDateTimeHumanizeStrategy(precision = .75)`.\r\n\r\nThe default precision is set to .75 but you can pass your desired precision too. With precision set to 0.75:\r\n\r\n```C#\r\n44 seconds => 44 seconds ago/from now\r\n45 seconds => one minute ago/from now\r\n104 seconds => one minute ago/from now\r\n105 seconds => two minutes ago/from now\r\n\r\n25 days => a month ago/from now\r\n```\r\n\r\n**No dehumanization for dates as `Humanize` is a lossy transformation and the human friendly date is not reversible**\r\n\r\n###<a id=\"humanize-timespan\">Humanize TimeSpan</a>\r\nYou can call `Humanize` on a `TimeSpan` to a get human friendly representation for it:\r\n\r\n```C#\r\nTimeSpan.FromMilliseconds(1).Humanize() => \"1 millisecond\"\r\nTimeSpan.FromMilliseconds(2).Humanize() => \"2 milliseconds\"\r\nTimeSpan.FromDays(1).Humanize() => \"1 day\"\r\nTimeSpan.FromDays(16).Humanize() => \"2 weeks\"\r\n```\r\n\r\nThere is an optional `precision` parameter for `TimeSpan.Humanize` which allows you to specify the precision of the returned value.\r\nThe default value of `precision` is 1 which means only the largest time unit is returned like you saw in `TimeSpan.FromDays(16).Humanize()`.\r\nHere is a few examples of specifying precision:\r\n\r\n```C#\r\nTimeSpan.FromDays(1).Humanize(precision:2) => \"1 day\" // no difference when there is only one unit in the provided TimeSpan\r\nTimeSpan.FromDays(16).Humanize(2) => \"2 weeks, 2 days\"\r\n\r\n// the same TimeSpan value with different precision returns different results\r\nTimeSpan.FromMilliseconds(1299630020).Humanize() => \"2 weeks\"\r\nTimeSpan.FromMilliseconds(1299630020).Humanize(3) => \"2 weeks, 1 day, 1 hour\"\r\nTimeSpan.FromMilliseconds(1299630020).Humanize(4) => \"2 weeks, 1 day, 1 hour, 30 seconds\"\r\nTimeSpan.FromMilliseconds(1299630020).Humanize(5) => \"2 weeks, 1 day, 1 hour, 30 seconds, 20 milliseconds\"\r\n```\r\n\r\nMany localizations are available for this method:\r\n\r\n```C#\r\n// in de-DE culture\r\nTimeSpan.FromDays(1).Humanize() => \"Ein Tag\"\r\nTimeSpan.FromDays(2).Humanize() => \"2 Tage\"\r\n\r\n// in sk-SK culture\r\nTimeSpan.FromMilliseconds(1).Humanize() => \"1 milisekunda\"\r\nTimeSpan.FromMilliseconds(2).Humanize() => \"2 milisekundy\"\r\nTimeSpan.FromMilliseconds(5).Humanize() => \"5 milisekúnd\"\r\n```\r\n\r\nCulture to use can be specified explicitly. If it is not, current thread's current UI culture is used. Example:\r\n\r\n```C#\r\nTimeSpan.FromDays(1).Humanize(culture: \"ru-RU\") => \"один день\"\r\n```\r\n\r\n###<a id=\"humanize-collections\">Humanize Collections</a>\r\nYou can call `Humanize` on any `IEnumerable` to get a nicely formatted string representing the objects in the collection. By default `ToString()` will be called on each item to get its representation but a formatting function may be passed to `Humanize` instead. Additionally, a default separator is provided(\"and\" in English), but a different separator may be passed into `Humanize`.\r\n\r\nFor instance:\r\n\r\n```C#\r\nclass SomeClass\r\n{\r\n    public string SomeString;\r\n    public int SomeInt;\r\n    public override string ToString()\r\n    {\r\n        return \"Specific String\";\r\n    }\r\n}\r\n\r\nstring FormatSomeClass(SomeClass sc)\r\n{\r\n\treturn string.Format(\"SomeObject #{0} - {1}\", sc.SomeInt, sc.SomeString);\r\n}\r\n\r\nvar collection = new List<SomeClass>\r\n    {\r\n        new SomeClass { SomeInt = 1, SomeString = \"One\" },\r\n        new SomeClass { SomeInt = 2, SomeString = \"Two\" },\r\n        new SomeClass { SomeInt = 3, SomeString = \"Three\" }\r\n    };\r\n\r\ncollection.Humanize()                                    // \"Specific String, Specific String, and Specific String\"\r\ncollection.Humanize(\"or\")                                //\"Specific String, Specific String, or Specific String\"\r\ncollection.Humanize(FormatSomeClass)                     //\"SomeObject #1 - One, SomeObject #2 - Two, and SomeObject #3 - Three\"\r\ncollection.Humanize(sc => sc.SomeInt.Ordinalize(), \"or\") //\"1st, 2nd, or 3rd\"\r\n```\r\n\r\nYou can provide your own collection formatter by implementing `ICollectionFormatter` and registering it with `Configurator.CollectionFormatters`\r\n\r\n###<a id=\"inflector-methods\">Inflector methods</a>\r\nThere are also a few inflector methods:\r\n\r\n####<a id=\"pluralize\">Pluralize</a>\r\n`Pluralize` pluralizes the provided input while taking irregular and uncountable words into consideration:\r\n\r\n```C#\r\n\"Man\".Pluralize() => \"Men\"\r\n\"string\".Pluralize() => \"strings\"\r\n```\r\n\r\nNormally you would call `Pluralize` on a singular word but if you're unsure about the singularity of the word you can call the method with the optional `inputIsKnownToBeSingular` argument:\r\n\r\n```C#\r\n\"Men\".Pluralize(inputIsKnownToBeSingular: false) => \"Men\"\r\n\"Man\".Pluralize(inputIsKnownToBeSingular: false) => \"Men\"\r\n\"string\".Pluralize(inputIsKnownToBeSingular: false) => \"strings\"\r\n```\r\n\r\n\r\nThe overload of `Pluralize` with `plurality` argument is obsolete and will be removed in next major release.\r\n\r\n####<a id=\"singularize\">Singularize</a>\r\n`Singularize` singularizes the provided input while taking irregular and uncountable words into consideration:\r\n\r\n```C#\r\n\"Men\".Singularize() => \"Man\"\r\n\"strings\".Singularize() => \"string\"\r\n```\r\n\r\nNormally you would call `Singularize` on a plural word but if you're unsure about the plurality of the word you can call the method with the optional `inputIsKnownToBePlural` argument:\r\n\r\n```C#\r\n\"Men\".Singularize(inputIsKnownToBePlural: false) => \"Man\"\r\n\"Man\".Singularize(inputIsKnownToBePlural: false) => \"Man\"\r\n\"strings\".Singularize(inputIsKnownToBePlural: false) => \"string\"\r\n```\r\n\r\n\r\nThe overload of `Singularize` with `plurality` argument is obsolete and will be removed in next major release.\r\n\r\n####<a id=\"toquantity\">ToQuantity</a>\r\nMany times you want to call `Singularize` and `Pluralize` to prefix a word with a number; e.g. \"2 requests\", \"3 men\". `ToQuantity` prefixes the provided word with the number and accordingly pluralizes or singularizes the word:\r\n\r\n```C#\r\n\"case\".ToQuantity(0) => \"0 cases\"\r\n\"case\".ToQuantity(1) => \"1 case\"\r\n\"case\".ToQuantity(5) => \"5 cases\"\r\n\"man\".ToQuantity(0) => \"0 men\"\r\n\"man\".ToQuantity(1) => \"1 man\"\r\n\"man\".ToQuantity(2) => \"2 men\"\r\n```\r\n\r\n`ToQuantity` can figure out whether the input word is singular or plural and will singularize or pluralize as necessary:\r\n\r\n```C#\r\n\"men\".ToQuantity(2) => \"2 men\"\r\n\"process\".ToQuantity(2) => \"2 processes\"\r\n\"process\".ToQuantity(1) => \"1 process\"\r\n\"processes\".ToQuantity(2) => \"2 processes\"\r\n\"processes\".ToQuantity(1) => \"1 process\"\r\n```\r\n\r\nYou can also pass a second argument, `ShowQuantityAs`, to `ToQuantity` to specify how you want the provided quantity to be outputted. The default value is `ShowQuantityAs.Numeric` which is what we saw above. The other two values are `ShowQuantityAs.Words` and `ShowQuantityAs.None`.\r\n\r\n```C#\r\n\"case\".ToQuantity(5, ShowQuantityAs.Words) => \"five cases\"\r\n\"case\".ToQuantity(5, ShowQuantityAs.None) => \"cases\"\r\n```\r\n\r\nThere is also an overload that allows you to format the number. You can pass in the format and the culture to be used.\r\n\r\n```C#\r\n\"dollar\".ToQuantity(2, \"C0\", new CultureInfo(\"en-US\")) => \"$2 dollars\"\r\n\"dollar\".ToQuantity(2, \"C2\", new CultureInfo(\"en-US\")) => \"$2.00 dollars\"\r\n\"cases\".ToQuantity(12000, \"N0\") => \"12,000 cases\"\r\n```\r\n\r\n####<a id=\"ordinalize\">Ordinalize</a>\r\n`Ordinalize` turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th:\r\n\r\n```C#\r\n1.Ordinalize() => \"1st\"\r\n5.Ordinalize() => \"5th\"\r\n```\r\n\r\nYou can also call `Ordinalize` on a numeric string and achieve the same result: `\"21\".Ordinalize()` => `\"21st\"`\r\n\r\n`Ordinalize` also supports grammatical gender for both forms.\r\nYou can pass an argument to `Ordinalize` to specify which gender the number should be outputted in.\r\nThe possible values are `GrammaticalGender.Masculine`, `GrammaticalGender.Feminine` and `GrammaticalGender.Neuter`:\r\n\r\n```C#\r\n// for Brazilian Portuguese locale\r\n1.ToOrdinalWords(GrammaticalGender.Masculine) => \"1º\"\r\n1.ToOrdinalWords(GrammaticalGender.Feminine) => \"1ª\"\r\n1.ToOrdinalWords(GrammaticalGender.Neuter) => \"1º\"\r\n\"2\".ToOrdinalWords(GrammaticalGender.Masculine) => \"2º\"\r\n\"2\".ToOrdinalWords(GrammaticalGender.Feminine) => \"2ª\"\r\n\"2\".ToOrdinalWords(GrammaticalGender.Neuter) => \"2º\"\r\n```\r\n\r\nObviously this only applies to some cultures. For others passing gender in or not passing at all doesn't make any difference in the result.\r\n\r\n####<a id=\"underscore\">Underscore</a>\r\n`Underscore` separates the input words with underscore; e.g. `\"SomeTitle\".Underscore()` => `\"some_title\"`\r\n\r\n####<a id=\"dasherize--hyphenate\">Dasherize & Hyphenate</a>\r\n`Dasherize` and `Hyphenate` replace underscores with dashes in the string:\r\n\r\n```C3\r\n\"some_title\".Dasherize() => \"some-title\"\r\n\"some_title\".Hyphenate() => \"some-title\"\r\n```\r\n\r\n###<a id=\"fluent-date\">Fluent Date</a>\r\nHumanizer provides a fluent API to deal with `DateTime` and `TimeSpan` as follows:\r\n\r\n`TimeSpan` methods:\r\n\r\n```C#\r\n2.Milliseconds() => TimeSpan.FromMilliseconds(2)\r\n2.Seconds() => TimeSpan.FromSeconds(2)\r\n2.Minutes() => TimeSpan.FromMinutes(2)\r\n2.Hours() => TimeSpan.FromHours(2)\r\n2.Days() => TimeSpan.FromDays(2)\r\n2.Weeks() => TimeSpan.FromDays(14)\r\n```\r\n\r\n<small>There are no fluent APIs for month or year as a month could have between 28 to 31 days and a year could be 365 or 366 days.</small>\r\n\r\nYou could use these methods to, for example, replace\r\n\r\n```C#\r\nDateTime.Now.AddDays(2).AddHours(3).AddMinutes(-5)\r\n```\r\n\r\nwith\r\n\r\n```C#\r\nDateTime.Now + 2.Days() + 3.Hours() - 5.Minutes()\r\n```\r\n\r\nThere are also three categories of fluent methods to deal with `DateTime`:\r\n\r\n```C#\r\nIn.TheYear(2010) // Returns the first of January of 2010\r\nIn.January // Returns 1st of January of the current year\r\nIn.FebruaryOf(2009) // Returns 1st of February of 2009\r\n\r\nIn.One.Second //  DateTime.UtcNow.AddSeconds(1);\r\nIn.Two.SecondsFrom(DateTime dateTime)\r\nIn.Three.Minutes // With corresponding From method\r\nIn.Three.Hours // With corresponding From method\r\nIn.Three.Days // With corresponding From method\r\nIn.Three.Weeks // With corresponding From method\r\nIn.Three.Months // With corresponding From method\r\nIn.Three.Years // With corresponding From method\r\n\r\nOn.January.The4th // Returns 4th of January of the current year\r\nOn.February.The(12) // Returns 12th of Feb of the current year\r\n```\r\n\r\nand some extension methods:\r\n\r\n```C#\r\nvar someDateTime = new DateTime(2011, 2, 10, 5, 25, 45, 125);\r\n\r\n// Returns new DateTime(2008, 2, 10, 5, 25, 45, 125) changing the year to 2008\r\nsomeDateTime.In(2008)\r\n\r\n// Returns new DateTime(2011, 2, 10, 2, 25, 45, 125) changing the hour to 2:25:45.125\r\nsomeDateTime.At(2)\r\n\r\n// Returns new DateTime(2011, 2, 10, 2, 20, 15, 125) changing the time to 2:20:15.125\r\nsomeDateTime.At(2, 20, 15)\r\n\r\n// Returns new DateTime(2011, 2, 10, 12, 0, 0) changing the time to 12:00:00.000\r\nsomeDateTime.AtNoon()\r\n\r\n// Returns new DateTime(2011, 2, 10, 0, 0, 0) changing the time to 00:00:00.000\r\nsomeDateTime.AtMidnight()\r\n```\r\n\r\nObviously you could chain the methods too; e.g. `On.November.The13th.In(2010).AtNoon + 5.Minutes()`\r\n\r\n###<a id=\"number-towords\">Number to words</a>\r\nHumanizer can change numbers to words using the `ToWords` extension:\r\n\r\n```C#\r\n1.ToWords() => \"one\"\r\n10.ToWords() => \"ten\"\r\n11.ToWords() => \"eleven\"\r\n122.ToWords() => \"one hundred and twenty-two\"\r\n3501.ToWords() => \"three thousand five hundred and one\"\r\n```\r\n\r\nYou can also pass a second argument, `GrammaticalGender`, to `ToWords` to specify which gender the number should be outputted in.\r\nThe possible values are `GrammaticalGender.Masculine`, `GrammaticalGender.Feminine` and `GrammaticalGender.Neuter`:\r\n\r\n```C#\r\n// for Russian locale\r\n1.ToWords(GrammaticalGender.Masculine) => \"один\"\r\n1.ToWords(GrammaticalGender.Feminine) => \"одна\"\r\n1.ToWords(GrammaticalGender.Neuter) => \"одно\"\r\n```\r\n\r\nObviously this only applies to some cultures. For others passing gender in doesn't make any difference in the result.\r\n\r\nAlso, culture to use can be specified explicitly. If it is not, current thread's current UI culture is used. Here's an example:\r\n\r\n```C#\r\n11.ToWords(new CultureInfo(\"en\")) => \"eleven\"\r\n1.ToWords(GrammaticalGender.Masculine, new CultureInfo(\"ru\")) => \"один\"\r\n```\r\n\r\n###<a id=\"number-toordinalwords\">Number to ordinal words</a>\r\nThis is kind of mixing `ToWords` with `Ordinalize`. You can call `ToOrdinalWords` on a number to get an ordinal representation of the number in words! For example:\r\n\r\n```C#\r\n0.ToOrdinalWords() => \"zeroth\"\r\n1.ToOrdinalWords() => \"first\"\r\n2.ToOrdinalWords() => \"second\"\r\n8.ToOrdinalWords() => \"eighth\"\r\n10.ToOrdinalWords() => \"tenth\"\r\n11.ToOrdinalWords() => \"eleventh\"\r\n12.ToOrdinalWords() => \"twelfth\"\r\n20.ToOrdinalWords() => \"twentieth\"\r\n21.ToOrdinalWords() => \"twenty first\"\r\n121.ToOrdinalWords() => \"hundred and twenty first\"\r\n```\r\n\r\n`ToOrdinalWords` also supports grammatical gender.\r\nYou can pass a second argument to `ToOrdinalWords` to specify the gender of the output.\r\nThe possible values are `GrammaticalGender.Masculine`, `GrammaticalGender.Feminine` and `GrammaticalGender.Neuter`:\r\n\r\n```C#\r\n// for Brazilian Portuguese locale\r\n1.ToOrdinalWords(GrammaticalGender.Masculine) => \"primeiro\"\r\n1.ToOrdinalWords(GrammaticalGender.Feminine) => \"primeira\"\r\n1.ToOrdinalWords(GrammaticalGender.Neuter) => \"primeiro\"\r\n2.ToOrdinalWords(GrammaticalGender.Masculine) => \"segundo\"\r\n2.ToOrdinalWords(GrammaticalGender.Feminine) => \"segunda\"\r\n2.ToOrdinalWords(GrammaticalGender.Neuter) => \"segundo\"\r\n```\r\n\r\nObviously this only applies to some cultures. For others passing gender in doesn't make any difference in the result.\r\n\r\nAlso, culture to use can be specified explicitly. If it is not, current thread's current UI culture is used. Here's an example:\r\n\r\n```C#\r\n10.ToOrdinalWords(new CultureInfo(\"en-US\")) => \"tenth\"\r\n1.ToOrdinalWords(GrammaticalGender.Masculine, new CulureInfo(\"pt-BR\")) => \"primeiro\"\r\n```\r\n\r\n###<a id=\"roman-numerals\">Roman numerals</a>\r\nHumanizer can change numbers to Roman numerals using the `ToRoman` extension. The numbers 1 to 10 can be expressed in Roman numerals as follows:\r\n\r\n```C#\r\n1.ToRoman() => \"I\"\r\n2.ToRoman() => \"II\"\r\n3.ToRoman() => \"III\"\r\n4.ToRoman() => \"IV\"\r\n5.ToRoman() => \"V\"\r\n6.ToRoman() => \"VI\"\r\n7.ToRoman() => \"VII\"\r\n8.ToRoman() => \"VIII\"\r\n9.ToRoman() => \"IX\"\r\n10.ToRoman() => \"X\"\r\n```\r\n\r\nAlso the reverse operation using the `FromRoman` extension.\r\n\r\n```C#\r\n\"I\".FromRoman() => 1\r\n\"II\".FromRoman() => 2\r\n\"III\".FromRoman() => 3\r\n\"IV\".FromRoman() => 4\r\n\"V\".FromRoman() => 5\r\n```\r\n\r\n###<a id=\"bytesize\">ByteSize</a>\r\nHumanizer includes a port of the brilliant [ByteSize](https://github.com/omar/ByteSize) library.\r\nQuite a few changes and additions are made on `ByteSize` to make the interaction with `ByteSize` easier and more consistent with the Humanizer API.\r\nHere is a few examples of how you can convert from numbers to byte sizes and between size magnitudes:\r\n\r\n```c#\r\nvar fileSize = (10).Kilobytes();\r\n\r\nfileSize.Bits      => 81920\r\nfileSize.Bytes     => 10240\r\nfileSize.Kilobytes => 10\r\nfileSize.Megabytes => 0.009765625\r\nfileSize.Gigabytes => 9.53674316e-6\r\nfileSize.Terabytes => 9.31322575e-9\r\n```\r\n\r\nThere are a few extension methods that allow you to turn a number into a ByteSize instance:\r\n\r\n```C#\r\n3.Bits();\r\n5.Bytes();\r\n(10.5).Kilobytes();\r\n(2.5).Megabytes();\r\n(10.2).Gigabytes();\r\n(4.7).Terabytes();\r\n```\r\n\r\nYou can also add/subtract the values using +/- operators and Add/Subtract methods:\r\n\r\n```C#\r\nvar total = (10).Gigabytes() + (512).Megabytes() - (2.5).Gigabytes();\r\ntotal.Subtract((2500).Kilobytes()).Add((25).Megabytes());\r\n```\r\n\r\nA `ByteSize` object contains two properties that represent the largest metric prefix symbol and value:\r\n\r\n```C#\r\nvar maxFileSize = (10).Kilobytes();\r\n\r\nmaxFileSize.LargestWholeNumberSymbol;  // \"KB\"\r\nmaxFileSize.LargestWholeNumberValue;   // 10\r\n```\r\n\r\nIf you want a string representation you can call `ToString` or `Humanize` interchangeably on the `ByteSize` instance:\r\n\r\n```C#\r\n7.Bits().ToString();         // 7 b\r\n8.Bits().ToString();         // 1 B\r\n(.5).Kilobytes().Humanize();   // 512 B\r\n(1000).Kilobytes().ToString(); // 1000 KB\r\n(1024).Kilobytes().Humanize(); // 1 MB\r\n(.5).Gigabytes().Humanize();   // 512 MB\r\n(1024).Gigabytes().ToString(); // 1 TB\r\n```\r\n\r\nYou can also optionally provide a format for the expected string representation.\r\nThe formatter can contain the symbol of the value to display: `b`, `B`, `KB`, `MB`, `GB`, `TB`.\r\nThe formatter uses the built in [`double.ToString` method](http://msdn.microsoft.com/en-us/library/kfsatb94\\(v=vs.110\\).aspx) with `#.##` as the default format which rounds the number to two decimal places:\r\n\r\n```C#\r\nvar b = (10.505).Kilobytes();\r\n\r\n// Default number format is #.##\r\nb.ToString(\"KB\");         // 10.52 KB\r\nb.Humanize(\"MB\");         // .01 MB\r\nb.Humanize(\"b\");          // 86057 b\r\n\r\n// Default symbol is the largest metric prefix value >= 1\r\nb.ToString(\"#.#\");        // 10.5 KB\r\n\r\n// All valid values of double.ToString(string format) are acceptable\r\nb.ToString(\"0.0000\");     // 10.5050 KB\r\nb.Humanize(\"000.00\");     // 010.51 KB\r\n\r\n// You can include number format and symbols\r\nb.ToString(\"#.#### MB\");  // .0103 MB\r\nb.Humanize(\"0.00 GB\");    // 0 GB\r\nb.Humanize(\"#.## B\");     // 10757.12 B\r\n```\r\n\r\nThere isn't a `Dehumanize` method to turn a string representation back into a `ByteSize` instance; but you can use `Parse` and `TryParse` on `ByteSize` to do that.\r\nLike other `TryParse` methods, `ByteSize.TryParse` returns `boolean` value indicating whether or not the parsing was successful.\r\nIf the value is parsed it is output to the `out` parameter supplied:\r\n\r\n```\r\nByteSize output;\r\nByteSize.TryParse(\"1.5mb\", out output);\r\n\r\n// Invalid\r\nByteSize.Parse(\"1.5 b\");   // Can't have partial bits\r\n\r\n// Valid\r\nByteSize.Parse(\"5b\");\r\nByteSize.Parse(\"1.55B\");\r\nByteSize.Parse(\"1.55KB\");\r\nByteSize.Parse(\"1.55 kB \"); // Spaces are trimmed\r\nByteSize.Parse(\"1.55 kb\");\r\nByteSize.Parse(\"1.55 MB\");\r\nByteSize.Parse(\"1.55 mB\");\r\nByteSize.Parse(\"1.55 mb\");\r\nByteSize.Parse(\"1.55 GB\");\r\nByteSize.Parse(\"1.55 gB\");\r\nByteSize.Parse(\"1.55 gb\");\r\nByteSize.Parse(\"1.55 TB\");\r\nByteSize.Parse(\"1.55 tB\");\r\nByteSize.Parse(\"1.55 tb\");\r\n```\r\n\r\n##<a id=\"mix-this-into-your-framework-to-simplify-your-life\">Mix this into your framework to simplify your life</a>\r\nThis is just a baseline and you can use this to simplify your day to day job. For example, in Asp.Net MVC we keep chucking `Display` attribute on ViewModel properties so `HtmlHelper` can generate correct labels for us; but, just like enums, in vast majority of cases we just need a space between the words in property name - so why not use `\"string\".Humanize` for that?!\r\n\r\nYou may find an Asp.Net MVC sample [in the code](https://github.com/MehdiK/Humanizer/tree/master/src/Humanizer.MvcSample) that does that (although the project is excluded from the solution file to make the nuget package available for .Net 3.5 too).\r\n\r\nThis is achieved using a custom `DataAnnotationsModelMetadataProvider` I called [HumanizerMetadataProvider](https://github.com/MehdiK/Humanizer/blob/master/src/Humanizer.MvcSample/HumanizerMetadataProvider.cs). It is small enough to repeat here; so here we go:\r\n\r\n```C#\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.Linq;\r\nusing System.Web.Mvc;\r\nusing Humanizer;\r\n\r\nnamespace YourApp\r\n{\r\n    public class HumanizerMetadataProvider : DataAnnotationsModelMetadataProvider\r\n    {\r\n        protected override ModelMetadata CreateMetadata(\r\n            IEnumerable<Attribute> attributes,\r\n            Type containerType,\r\n            Func<object> modelAccessor,\r\n            Type modelType,\r\n            string propertyName)\r\n        {\r\n            var propertyAttributes = attributes.ToList();\r\n            var modelMetadata = base.CreateMetadata(propertyAttributes, containerType, modelAccessor, modelType, propertyName);\r\n\r\n            if (IsTransformRequired(modelMetadata, propertyAttributes))\r\n                modelMetadata.DisplayName = modelMetadata.PropertyName.Humanize();\r\n\r\n            return modelMetadata;\r\n        }\r\n\r\n        private static bool IsTransformRequired(ModelMetadata modelMetadata, IList<Attribute> propertyAttributes)\r\n        {\r\n            if (string.IsNullOrEmpty(modelMetadata.PropertyName))\r\n                return false;\r\n\r\n            if (propertyAttributes.OfType<DisplayNameAttribute>().Any())\r\n                return false;\r\n\r\n            if (propertyAttributes.OfType<DisplayAttribute>().Any())\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis class calls the base class to extract the metadata and then, if required, humanizes the property name.\r\nIt is checking if the property already has a `DisplayName` or `Display` attribute on it in which case the metadata provider will just honor the attribute and leave the property alone.\r\nFor other properties it will Humanize the property name. That is all.\r\n\r\nNow you need to register this metadata provider with Asp.Net MVC.\r\nMake sure you use `System.Web.Mvc.ModelMetadataProviders`, and not `System.Web.ModelBinding.ModelMetadataProviders`:\r\n\r\n```C#\r\nModelMetadataProviders.Current = new HumanizerMetadataProvider();\r\n```\r\n\r\n... and now you can replace:\r\n\r\n```C#\r\npublic class RegisterModel\r\n{\r\n    [Display(Name = \"User name\")]\r\n    public string UserName { get; set; }\r\n\r\n    [Display(Name = \"Email address\")]\r\n    public string EmailAddress { get; set; }\r\n\r\n    [Display(Name = \"Confirm password\")]\r\n    public string ConfirmPassword { get; set; }\r\n}\r\n```\r\n\r\nwith:\r\n\r\n```C#\r\npublic class RegisterModel\r\n{\r\n    public string UserName { get; set; }\r\n    public string EmailAddress { get; set; }\r\n    public string ConfirmPassword { get; set; }\r\n}\r\n```\r\n\r\n... and the \"metadata humanizer\" will take care of the rest.\r\n\r\nNo need to mention that if you want title casing for your labels you can chain the method with `Transform`:\r\n\r\n```C#\r\nmodelMetadata.DisplayName = modelMetadata.PropertyName.Humanize().Transform(To.TitleCase);\r\n```\r\n\r\n##<a id=\"how-to-contribute\">How to contribute?</a>\r\n\r\nPlease see <a href=\"https://github.com/MehdiK/Humanizer/blob/master/CONTRIBUTING.md\">CONTRIBUTING.md</a>.\r\n\r\n##<a id=\"continuous-integration-from-teamcity\">Continuous Integration from TeamCity</a>\r\nHumanizer project is built & tested continuously by TeamCity (more details [here](http://www.mehdi-khalili.com/continuous-integration-delivery-github-teamcity)). That applies to pull requests too. Shortly after you submit a PR you can check the build and test status notification on your PR. Feel free to jump in and <a href=\"https://github.com/MehdiK/Humanizer/blob/master/CONTRIBUTING.md\">contribute</a> some green PRs!\r\n\r\nThe current build status on the CI server is <a href=\"http://teamcity.ginnivan.net/viewType.html?buildTypeId=Humanizer_CI&guest=1\">\r\n<img src=\"http://teamcity.ginnivan.net/app/rest/builds/buildType:(id:Humanizer_CI)/statusIcon\"/></a>\r\n\r\n##<a id=\"author\">Author</a>\r\nMehdi Khalili ([@MehdiKhalili](http://twitter.com/MehdiKhalili))\r\n\r\n##<a id=\"main-contributors\">Main contributors</a>\r\nAlexander I. Zaytsev ([@hazzik](https://github.com/hazzik))\r\nMax Malook ([@mexx](https://github.com/mexx))\r\n\r\n##<a id=\"license\">License</a>\r\nHumanizer is released under the MIT License. See the [bundled LICENSE](https://github.com/MehdiK/Humanizer/blob/master/LICENSE) file for details.\r\n\r\n##<a id=\"icon\">Icon</a>\r\nIcon created by [Tyrone Rieschiek](https://twitter.com/Inkventive)\r\n","google":"UA-49249463-1","note":"Don't delete this file! It's used internally to help with page regeneration."}